{% extends "base.html" %}

{% block title %}Task Status{% endblock %}

{% block head %}
{{ super() }}
<style>
    .progress { 
        height: 20px; 
        margin-bottom: 10px; 
    }
    .progress-bar { 
        transition: width 0.3s ease-in-out; 
    }
    .logs-container {
        height: 400px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 0.9rem;
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 4px;
    }
    .log-entry {
        margin-bottom: 0.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #eee;
    }
    .log-entry .timestamp {
        color: #666;
        margin-right: 1rem;
    }
    .log-entry.search { color: #0dcaf0; }
    .log-entry.clean { color: #ffc107; }
    .log-entry.analyze { color: #198754; }
    
    .connection-status {
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 0.8rem;
        z-index: 1000;
    }
    .connection-status.connected { 
        background: #198754;
        color: white;
    }
    .connection-status.disconnected { 
        background: #dc3545;
        color: white;
    }
    .connection-status.connecting { 
        background: #ffc107;
        color: black;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div id="connectionStatus" class="connection-status disconnected">
        Отключено
    </div>

    <h2>Task Status</h2>
    
    <div class="card mb-4">
        <div class="card-body">
            <h5 class="card-title">Progress</h5>
            <div class="progress mb-3">
                <div class="progress-bar" role="progressbar" style="width: {{ task.progress if task.progress else 0 }}%;" 
                     id="totalProgress">{{ task.progress if task.progress else 0 }}%</div>
            </div>
            
            <!-- Этапы с отдельными прогресс-барами -->
            <div class="stages">
                <div class="stage mb-2">
                    <label>Search</label>
                    <div class="progress">
                        <div class="progress-bar bg-info" role="progressbar" id="searchProgress" style="width: 0%">0%</div>
                    </div>
                </div>
                <div class="stage mb-2">
                    <label>Clean</label>
                    <div class="progress">
                        <div class="progress-bar bg-info" role="progressbar" id="cleanProgress" style="width: 0%">0%</div>
                    </div>
                </div>
                <div class="stage mb-2">
                    <label>Analyze</label>
                    <div class="progress">
                        <div class="progress-bar bg-info" role="progressbar" id="analyzeProgress" style="width: 0%">0%</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Логи -->
    <div class="card">
        <div class="card-body">
            <h5 class="card-title">Logs</h5>
            <div class="logs-container">
                <div id="logs" class="bg-light p-3"></div>
            </div>
        </div>
    </div>

    <!-- Кнопки действий -->
    <div class="mt-4">
        {% if task.status == 'completed' %}
            <a href="{{ url_for('main.task_results', task_id=task.id) }}" 
               class="btn btn-success">View Results</a>
        {% endif %}
        <a href="{{ url_for('main.client_detail', id=task.client_id) }}" 
           class="btn btn-secondary">Back to Client</a>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const taskId = {{ task.id }};
    const logsContainer = document.getElementById('logs');
    const connectionStatus = document.getElementById('connectionStatus');
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    
    function updateConnectionStatus(status, message) {
        connectionStatus.className = 'connection-status ' + status;
        connectionStatus.textContent = message;
    }
    
    updateConnectionStatus('connecting', 'Подключение...');
    
    // Инициализируем сокет с новыми настройками
    const socket = io({
        path: '/socket.io',
        transports: ['websocket'],
        upgrade: false,  // Используем только WebSocket
        reconnection: true,
        reconnectionAttempts: maxReconnectAttempts,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 20000,
        forceNew: true
    });
    
    // Обработчики событий сокета
    socket.on('connect', function() {
        console.log('Connected to Socket.IO');
        updateConnectionStatus('connected', 'Подключено');
        reconnectAttempts = 0;
        socket.emit('join', {task_id: taskId});
    });

    socket.on('connect_error', function(error) {
        console.error('Socket.IO connection error:', error);
        updateConnectionStatus('disconnected', 'Ошибка подключения');
        reconnectAttempts++;
        
        if (reconnectAttempts >= maxReconnectAttempts) {
            updateConnectionStatus('disconnected', 'Не удалось подключиться');
            socket.disconnect();
        }
    });

    socket.on('disconnect', function() {
        console.log('Disconnected from Socket.IO');
        updateConnectionStatus('disconnected', 'Отключено');
    });

    socket.on('reconnecting', function(attemptNumber) {
        console.log('Attempting to reconnect:', attemptNumber);
        updateConnectionStatus('connecting', `Переподключение (${attemptNumber}/${maxReconnectAttempts})...`);
    });

    socket.on('join_response', function(data) {
        console.log('Join response:', data);
        if (data.status === 'joined') {
            addLogEntry('System', `Подключено к комнате: ${data.room}`);
        }
    });

    socket.on('task_update', function(data) {
        console.log('Received task update:', data);
        
        // Обновляем общий прогресс
        if (data.progress !== null && data.progress !== undefined) {
            console.log(`Updating total progress: ${data.progress}%`);
            const totalProgressBar = document.getElementById('totalProgress');
            totalProgressBar.style.width = data.progress + '%';
            totalProgressBar.textContent = data.progress + '%';
        }
        
        // Обновляем прогресс этапа
        if (data.stage && data.stage_progress !== null && data.stage_progress !== undefined) {
            console.log(`Updating ${data.stage} progress: ${data.stage_progress}%`);
            const stageProgressBar = document.getElementById(data.stage + 'Progress');
            if (stageProgressBar) {
                stageProgressBar.style.width = data.stage_progress + '%';
                stageProgressBar.textContent = data.stage_progress + '%';
            } else {
                console.error(`Progress bar element for stage "${data.stage}" not found!`);
                console.log('Available progress bars:', 
                    ['searchProgress', 'cleanProgress', 'analyzeProgress'].map(id => 
                        `${id}: ${document.getElementById(id) ? 'found' : 'not found'}`
                    )
                );
            }
        }
        
        // Добавляем лог
        if (data.message) {
            addLogEntry(data.stage || 'System', data.message);
        }
        
        // Если задача завершена, обновляем страницу
        if (data.status === 'completed') {
            setTimeout(() => location.reload(), 1000);
        }
    });
    
    function addLogEntry(type, message) {
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry ' + (type.toLowerCase() || '');
        
        const timestamp = document.createElement('span');
        timestamp.className = 'timestamp';
        timestamp.textContent = new Date().toLocaleTimeString();
        
        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;
        
        logEntry.appendChild(timestamp);
        logEntry.appendChild(messageSpan);
        logsContainer.appendChild(logEntry);
        
        // Прокручиваем к последнему сообщению
        logsContainer.scrollTop = logsContainer.scrollHeight;
    }
});
</script>
{% endblock %}
